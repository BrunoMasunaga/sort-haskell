
==================== FINAL INTERFACE ====================
2018-08-10 19:27:13.995670441 UTC

interface main:Sorting 8043
  interface hash: a3c4321d51da7ac620d949a5fb8e9f65
  ABI hash: 044ca801717eeafd4d3c711363d05312
  export-list hash: 0791d7081be824a6e348dbf44adb51ba
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 2ca58541161456f760201087e169b356
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Sorting.adicionar
  Sorting.bubbleSort
  Sorting.bucketSort
  Sorting.chamadaBubble
  Sorting.chamadaHeap
  Sorting.chamadaRadix
  Sorting.construirAuxiliar
  Sorting.construirHeap
  Sorting.contarOcorrencias
  Sorting.countingSort
  Sorting.criarBucket
  Sorting.criarBuckets
  Sorting.dividir
  Sorting.dividirPivot
  Sorting.divisor
  Sorting.encontrarBucket
  Sorting.encontrarMaximo
  Sorting.heapSort
  Sorting.inserir
  Sorting.insertionSort
  Sorting.intercalar
  Sorting.maiorElemento
  Sorting.maxHeapify
  Sorting.mergeSort
  Sorting.numDigitos
  Sorting.obterDigito
  Sorting.obterDigitos
  Sorting.ordenado
  Sorting.ordenarBuckets
  Sorting.ordenarDigitos
  Sorting.quickSort
  Sorting.radix
  Sorting.radixSort
  Sorting.recuperarNumeros
  Sorting.remover
  Sorting.selectionSort
  Sorting.tamanhoAuxiliar
  Sorting.trocar
module dependencies:
package dependencies: base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Real b4beb0389ba1ad5d9640aae67848c5d3
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
9fd723a5b6ca30ac69205754e58536af
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Sorting.$trModule3
                   Sorting.$trModule1) -}
ca964a1882c4872fa570531e226a1ce8
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Sorting.$trModule2) -}
285afc1dcc122112d200f6c3a94d35cc
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Sorting"#) -}
6a64d818d588d230cced0f1213389692
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Sorting.$trModule4) -}
5172c7452b26d545abeaf9a9d6fc8120
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
ceb075a25305bfd9aad310fad0380988
  $w$sinserir ::
    GHC.Types.Int
    -> [GHC.Types.Int] -> (# GHC.Types.Int, [GHC.Types.Int] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,1*U>,
     Inline: [0] -}
63186441ee05ac94fac022bbd7b9312e
  $wadicionar ::
    GHC.Types.Int
    -> GHC.Prim.Int# -> [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><S,1*U>,
     Inline: [0] -}
b809a60ac3f8d0d51142066cbeda24fc
  $wchamadaHeap :: GHC.Classes.Ord a => GHC.Prim.Int# -> [a] -> [a]
  {- Arity: 3, Strictness: <L,U(A,A,A,A,C(C1(U)),A,A,A)><S,1*U><L,U>,
     Inline: [0] -}
91a4ef243f8793f0403218dd757d7740
  $wconstruirHeap :: GHC.Classes.Ord a => GHC.Prim.Int# -> [a] -> [a]
  {- Arity: 3, Strictness: <L,U(A,A,A,A,C(C1(U)),A,A,A)><S,1*U><S,U>,
     Inline: [0] -}
387784cb0a7a8990fdb2184cdc023f47
  $wdividir :: [a] -> (# [a], [a] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ a (w :: [a]) ->
                 case w of wild {
                   [] -> (# GHC.Types.[] @ a, GHC.Types.[] @ a #)
                   : x ds
                   -> case ds of wild1 {
                        [] -> (# GHC.Types.: @ a x (GHC.Types.[] @ a), GHC.Types.[] @ a #)
                        : ipv ipv1
                        -> let {
                             metade :: GHC.Types.Int
                             = case GHC.List.$wlenAcc @ a wild 0# of ww2 { DEFAULT ->
                               GHC.Types.I# (GHC.Prim.uncheckedIShiftRA# ww2 1#) }
                           } in
                           (# case metade of wild2 { GHC.Types.I# y ->
                              case GHC.Prim.<# 0# y of lwild {
                                DEFAULT -> GHC.Types.[] @ a
                                1# -> GHC.List.$wunsafeTake @ a y wild } },
                              case metade of wild2 { GHC.Types.I# x1 ->
                              case GHC.Prim.<=# x1 0# of lwild {
                                DEFAULT -> Sorting.$wunsafeDrop @ a x1 wild
                                1# -> wild } } #) } }) -}
9970e49e7f88a70bd8616c4143951137
  $wdividirPivot :: GHC.Classes.Ord a => [a] -> (# [a], [a] #)
  {- Arity: 2,
     Strictness: <L,U(A,A,C(C1(U)),A,A,C(C1(U)),A,A)><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Classes.Ord a) (w1 :: [a]) ->
                 case w1 of wild {
                   [] -> case Sorting.dividirPivot1 ret_ty (# [a], [a] #) of {}
                   : x xs
                   -> (# GHC.List.filter
                           @ a
                           (\ (ds :: a) -> GHC.Classes.< @ a w ds x)
                           xs,
                         GHC.List.filter
                           @ a
                           (\ (ds :: a) -> GHC.Classes.>= @ a w ds x)
                           xs #) }) -}
43263e784ee4f26ce765de03ff9d9f9a
  $wdivisor :: [GHC.Types.Int] -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: [GHC.Types.Int]) ->
                 case w of wild {
                   [] -> case GHC.List.maximum2 ret_ty GHC.Prim.Int# of {}
                   : ipv ipv1
                   -> case ipv of ww { GHC.Types.I# ww1 ->
                      case GHC.List.$wgo ipv1 ww1 of ww2 { DEFAULT ->
                      case GHC.Classes.divInt#
                             (GHC.Prim.+# ww2 1#)
                             10# of ww4 { DEFAULT ->
                      GHC.Prim.+# ww4 1# } } } }) -}
57b5bb3f77b16aa2c8920a3a64b68bd9
  $wencontrarBucket ::
    GHC.Prim.Int# -> [GHC.Types.Int] -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: [GHC.Types.Int]) ->
                 case w of wild {
                   [] -> case GHC.List.maximum2 ret_ty GHC.Prim.Int# of {}
                   : ipv ipv1
                   -> case ipv of ww1 { GHC.Types.I# ww2 ->
                      case GHC.List.$wgo ipv1 ww2 of ww3 { DEFAULT ->
                      case GHC.Classes.divInt#
                             (GHC.Prim.+# ww3 1#)
                             10# of ww4 { DEFAULT ->
                      GHC.Real.$w$cdiv ww (GHC.Prim.+# ww4 1#) } } } }) -}
cb6f0d5a0d72d3b3a304a0c4a6240715
  $wencontrarMaximo ::
    GHC.Classes.Ord a =>
    GHC.Prim.Int# -> GHC.Prim.Int# -> [a] -> GHC.Types.Int
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,C(C1(U)),A,A,A)><S,U><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (w1 :: [a]) ->
                 let {
                   x :: GHC.Prim.Int# = GHC.Prim.+# (GHC.Prim.*# 2# ww) 2#
                 } in
                 let {
                   imaior :: GHC.Types.Int
                   = let {
                       x1 :: GHC.Prim.Int# = GHC.Prim.+# (GHC.Prim.*# 2# ww) 1#
                     } in
                     case GHC.Prim.<# x1 ww1 of lwild {
                       DEFAULT -> GHC.Types.I# ww
                       1#
                       -> case GHC.Classes.>
                                 @ a
                                 w
                                 (GHC.List.$w!! @ a w1 x1)
                                 (GHC.List.$w!! @ a w1 ww) of wild {
                            GHC.Types.False -> GHC.Types.I# ww
                            GHC.Types.True -> GHC.Types.I# x1 } }
                 } in
                 case GHC.Prim.<# x ww1 of lwild {
                   DEFAULT -> imaior
                   1#
                   -> case GHC.Classes.>
                             @ a
                             w
                             (GHC.List.$w!! @ a w1 x)
                             (case imaior of ww2 { GHC.Types.I# ww3 ->
                              GHC.List.$w!! @ a w1 ww3 }) of wild {
                        GHC.Types.False -> imaior GHC.Types.True -> GHC.Types.I# x } }) -}
891e1a613617b9d96bf5e26cc0974a45
  $wgo1 :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>m,
     Inline: [0] -}
ddd8d02312b35d4660aebd84b42f693d
  $winserir :: GHC.Classes.Ord a => a -> [a] -> (# a, [a] #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>,
     Inline: [0] -}
79c003412d3e2f4c6b4025d21d693e61
  $wmaxHeapify ::
    GHC.Classes.Ord a => GHC.Prim.Int# -> GHC.Prim.Int# -> [a] -> [a]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,C(C1(U)),A,A,A)><S,U><S,U><L,U>,
     Inline: [0] -}
6d0b891f84b9bc6fd879c2eab39d22f3
  $wnumDigitos :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>, Inline: [0] -}
d635270fe74ac69717501028acd25d7f
  $wobterDigito :: GHC.Prim.Int# -> GHC.Types.Int -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(1*U)>,
     Inline: [0] -}
9f8588c84f8dfa949ef1fb330cdcf706
  $wradix ::
    [GHC.Types.Int]
    -> GHC.Prim.Int# -> GHC.Prim.Int# -> [GHC.Types.Int]
  {- Arity: 3, Strictness: <S,U><S,U><S,U>, Inline: [0] -}
56b1bd69ce5f7a643989f42fdfc197a9
  $wtamanhoAuxiliar :: [GHC.Types.Int] -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: [GHC.Types.Int]) ->
                 case w of wild {
                   [] -> case GHC.List.maximum2 ret_ty GHC.Prim.Int# of {}
                   : ipv ipv1
                   -> case ipv of ww { GHC.Types.I# ww1 ->
                      case GHC.List.$wgo ipv1 ww1 of ww2 { DEFAULT ->
                      case GHC.List.$wgo1 ipv1 ww1 of ww4 { DEFAULT ->
                      GHC.Prim.-# ww2 ww4 } } } }) -}
c8fa542363ae77cc9000d8a8c30f41d2
  $wtrocar :: GHC.Prim.Int# -> GHC.Prim.Int# -> [a] -> [a]
  {- Arity: 3, Strictness: <S,U><S,U><L,U>, Inline: [0] -}
adad0822a156919d1722fe51db3f54f3
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
2d15d345601dfa6554cb574ccc0e2dd3
  adicionar ::
    GHC.Types.Int
    -> GHC.Types.Int -> [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S(S),1*U(1*U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [GHC.Types.Int]) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Sorting.$wadicionar w ww1 w2 }) -}
b704718ac0a2d36b4448b7adb27624c8
  bubbleSort :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U> -}
2f3e394917ec823a9d4e139318be7048
  bucketSort :: [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [GHC.Types.Int]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Int
                   : x1 ds1
                   -> case ds1 of wild1 {
                        [] -> wild
                        : x2 xs
                        -> Sorting.bucketSort_go
                             (Sorting.ordenarBuckets (Sorting.criarBuckets wild)) } }) -}
87cf0278a8e761e86e54056a4c068c69
  bucketSort_go :: [[GHC.Types.Int]] -> [GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
313be64cc21994f61dc96ff6b2966709
  chamadaBubble :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2,
     Strictness: <S(LLLC(C(S))LLLL),U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U>m2,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: [a]) ->
                 case w1 of wild {
                   [] -> case Sorting.chamadaBubble1 ret_ty [a] of {}
                   : x1 ds
                   -> case ds of wild1 {
                        [] -> case Sorting.chamadaBubble1 ret_ty [a] of {}
                        : x2 xs
                        -> case GHC.Classes.<= @ a w x1 x2 of wild2 {
                             GHC.Types.False
                             -> GHC.Types.:
                                  @ a
                                  x2
                                  (Sorting.bubbleSort @ a w (GHC.Types.: @ a x1 xs))
                             GHC.Types.True
                             -> GHC.Types.: @ a x1 (Sorting.bubbleSort @ a w wild1) } } }) -}
1d35a19c85d4bbc100fa6619c8d319af
  chamadaBubble1 :: [a]
  {- Strictness: x -}
956c5b0409fbc45b8ca1e68049087a34
  chamadaHeap :: GHC.Classes.Ord a => GHC.Types.Int -> [a] -> [a]
  {- Arity: 3,
     Strictness: <L,U(A,A,A,A,C(C1(U)),A,A,A)><S(S),1*U(1*U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [a]) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Sorting.$wchamadaHeap @ a w ww1 w2 }) -}
ec996bfcab7d7b4cd0fe4a2b0b288485
  chamadaRadix :: [GHC.Types.Int] -> GHC.Types.Int -> [GHC.Types.Int]
  {- Arity: 2, Strictness: <S,U><L,U(U)>,
     Unfolding: (\ (xs :: [GHC.Types.Int]) (digito :: GHC.Types.Int) ->
                 letrec {
                   go :: [GHC.Types.Int] -> [GHC.Types.Int]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Types.Int]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Int
                       : y ys
                       -> GHC.Types.:
                            @ GHC.Types.Int
                            (GHC.List.!! @ GHC.Types.Int xs y)
                            (go ys) }
                 } in
                 go
                   (Sorting.chamadaRadix_go
                      (Sorting.chamadaRadix_$sselectionSort
                         (Sorting.obterDigitos xs digito Sorting.chamadaRadix1)))) -}
4785f65c4c212f2c889ae6c7922915f1
  chamadaRadix1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
c59257b143f9c54ed9451083ec7562dd
  chamadaRadix_$sselectionSort ::
    [(GHC.Types.Int, GHC.Types.Int)]
    -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
d5cac16e5ff9971b52838b4b861c3958
  chamadaRadix_go ::
    [(GHC.Types.Int, GHC.Types.Int)] -> [GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b3867585a7b8db77301807fb72703453
  construirAuxiliar :: [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (xs :: [GHC.Types.Int]) ->
                 case xs of wild {
                   [] -> case GHC.List.maximum2 ret_ty [GHC.Types.Int] of {}
                   : ipv ipv1
                   -> case ipv of ww { GHC.Types.I# ww1 ->
                      case GHC.List.$wgo ipv1 ww1 of ww2 { DEFAULT ->
                      case GHC.List.$wgo1 ipv1 ww1 of ww4 { DEFAULT ->
                      let {
                        y :: GHC.Prim.Int# = GHC.Prim.-# ww2 ww4
                      } in
                      case GHC.Prim.># 0# y of lwild {
                        DEFAULT
                        -> letrec {
                             go :: GHC.Prim.Int# -> [GHC.Types.Int]
                               {- Arity: 1, Strictness: <L,U> -}
                             = \ (x :: GHC.Prim.Int#) ->
                               GHC.Types.:
                                 @ GHC.Types.Int
                                 (let {
                                    x1 :: GHC.Prim.Int# = GHC.Prim.+# x ww4
                                  } in
                                  letrec {
                                    $wgo3 :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Types.Int
                                      <join 2> {- Arity: 2, Strictness: <S,1*U><S,U>m,
                                                  Inline: [0] -}
                                    = \ (w :: [GHC.Types.Int]) (ww5 :: GHC.Prim.Int#) ->
                                      case w of wild1 {
                                        [] -> GHC.Types.I# ww5
                                        : y1 ys
                                        -> case y1 of wild2 { GHC.Types.I# x2 ->
                                           case GHC.Prim.==# x2 x1 of lwild1 {
                                             DEFAULT -> $wgo3 ys ww5
                                             1# -> $wgo3 ys (GHC.Prim.+# ww5 1#) } } }
                                  } in
                                  $wgo3 wild 0#)
                                 (case GHC.Prim.==# x y of lwild1 {
                                    DEFAULT -> go (GHC.Prim.+# x 1#)
                                    1# -> GHC.Types.[] @ GHC.Types.Int })
                           } in
                           go 0#
                        1# -> GHC.Types.[] @ GHC.Types.Int } } } } }) -}
c4cda3ea8468a0993b24dbdcc73cf5b8
  construirHeap :: GHC.Classes.Ord a => GHC.Types.Int -> [a] -> [a]
  {- Arity: 3,
     Strictness: <L,U(A,A,A,A,C(C1(U)),A,A,A)><S(S),1*U(1*U)><S,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [a]) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Sorting.$wconstruirHeap @ a w ww1 w2 }) -}
a066ab1e2bcdb89e0305a2511afa7e0d
  contarOcorrencias ::
    GHC.Types.Int -> [GHC.Types.Int] -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,1*U>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: [GHC.Types.Int]) ->
                 letrec {
                   $wgo3 :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Types.Int
                     <join 2> {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: [0] -}
                   = \ (w2 :: [GHC.Types.Int]) (ww :: GHC.Prim.Int#) ->
                     case w2 of wild {
                       [] -> GHC.Types.I# ww
                       : y ys
                       -> case y of wild1 { GHC.Types.I# x ->
                          case w of wild2 { GHC.Types.I# y1 ->
                          case GHC.Prim.==# x y1 of lwild {
                            DEFAULT -> $wgo3 ys ww 1# -> $wgo3 ys (GHC.Prim.+# ww 1#) } } } }
                 } in
                 $wgo3 w1 0#) -}
f78e58de721791394801273298ea3ce7
  countingSort :: [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [GHC.Types.Int]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Int
                   : x ds1
                   -> case ds1 of wild1 {
                        [] -> GHC.Types.: @ GHC.Types.Int x (GHC.Types.[] @ GHC.Types.Int)
                        : ipv ipv1
                        -> case x of ww { GHC.Types.I# ww1 ->
                           case GHC.List.$wgo wild1 ww1 of ww2 { DEFAULT ->
                           case GHC.List.$wgo1 wild1 ww1 of ww4 { DEFAULT ->
                           let {
                             y :: GHC.Prim.Int# = GHC.Prim.-# ww2 ww4
                           } in
                           case GHC.Prim.># 0# y of lwild {
                             DEFAULT
                             -> let {
                                  min :: GHC.Types.Int = Sorting.$wgo1 wild1 ww1
                                } in
                                let {
                                  auxiliar :: [GHC.Types.Int] = Sorting.construirAuxiliar wild
                                } in
                                letrec {
                                  go :: GHC.Prim.Int# -> [GHC.Types.Int]
                                    {- Arity: 1, Strictness: <S,U> -}
                                  = \ (x1 :: GHC.Prim.Int#) ->
                                    case GHC.List.$w!!
                                           @ GHC.Types.Int
                                           auxiliar
                                           x1 of ww5 { GHC.Types.I# ww6 ->
                                    GHC.Base.++
                                      @ GHC.Types.Int
                                      (Sorting.$wadicionar
                                         (case min of wild2 { GHC.Types.I# y1 ->
                                          GHC.Types.I# (GHC.Prim.+# x1 y1) })
                                         ww6
                                         (GHC.Types.[] @ GHC.Types.Int))
                                      (case GHC.Prim.==# x1 y of lwild1 {
                                         DEFAULT -> go (GHC.Prim.+# x1 1#)
                                         1# -> GHC.Types.[] @ GHC.Types.Int }) }
                                } in
                                go 0#
                             1# -> GHC.Types.[] @ GHC.Types.Int } } } } } }) -}
6d68bc2027803855fb88a0e49340d0c7
  criarBucket :: [GHC.Types.Int] -> GHC.Types.Int -> [GHC.Types.Int]
  {- Arity: 2, Strictness: <S,U><L,U(U)>,
     Unfolding: (\ (xs :: [GHC.Types.Int]) (i :: GHC.Types.Int) ->
                 letrec {
                   go :: [GHC.Types.Int] -> [GHC.Types.Int]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Types.Int]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Int
                       : y ys
                       -> case y of ww { GHC.Types.I# ww1 ->
                          case Sorting.$wencontrarBucket ww1 xs of ww2 { DEFAULT ->
                          case i of wild1 { GHC.Types.I# y1 ->
                          case GHC.Prim.==# ww2 y1 of lwild {
                            DEFAULT -> go ys
                            1# -> GHC.Types.: @ GHC.Types.Int ww (go ys) } } } } }
                 } in
                 go xs) -}
21d1234141458fe4ce5779e619fcc65f
  criarBuckets :: [GHC.Types.Int] -> [[GHC.Types.Int]]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (xs :: [GHC.Types.Int]) ->
                 letrec {
                   go :: GHC.Prim.Int# -> [[GHC.Types.Int]]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Prim.Int#) ->
                     GHC.Types.:
                       @ [GHC.Types.Int]
                       (Sorting.criarBucket xs (GHC.Types.I# x))
                       (case x of wild {
                          DEFAULT -> go (GHC.Prim.+# wild 1#)
                          9# -> GHC.Types.[] @ [GHC.Types.Int] })
                 } in
                 go 0#) -}
2c60fbff4263673a191f806f7beb0848
  dividir :: GHC.Classes.Ord a => [a] -> ([a], [a])
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: [a]) ->
                 case Sorting.$wdividir @ a w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
2307efadfc54206d0d638b29b24e6993
  dividirPivot :: GHC.Classes.Ord a => [a] -> ([a], [a])
  {- Arity: 2,
     Strictness: <L,U(A,A,C(C1(U)),A,A,C(C1(U)),A,A)><S,1*U>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: [a]) ->
                 case Sorting.$wdividirPivot @ a w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
003116a5e99fedfaf448cda607671f51
  dividirPivot1 :: ([a], [a])
  {- Strictness: x -}
71967a97116c8719f96fef980f04163f
  divisor :: [GHC.Types.Int] -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [GHC.Types.Int]) ->
                 case Sorting.$wdivisor w of ww { DEFAULT -> GHC.Types.I# ww }) -}
e7560efb10b1733821b4bbdef813b24e
  encontrarBucket ::
    GHC.Types.Int -> [GHC.Types.Int] -> GHC.Types.Int
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: [GHC.Types.Int]) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case Sorting.$wencontrarBucket ww1 w1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
fc2749953aec2e990628f961e5639254
  encontrarMaximo ::
    GHC.Classes.Ord a =>
    GHC.Types.Int -> GHC.Types.Int -> [a] -> GHC.Types.Int
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,C(C1(U)),A,A,A)><S(S),1*U(U)><S(S),1*U(U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Types.Int)
                   (w3 :: [a]) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { GHC.Types.I# ww3 ->
                 Sorting.$wencontrarMaximo @ a w ww1 ww3 w3 } }) -}
7a9bacd3afff574f20e93853b69924b5
  heapSort :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2, Strictness: <L,U(A,A,A,A,C(C1(U)),A,A,A)><S,1*U>,
     Unfolding: (\ @ a ($dOrd :: GHC.Classes.Ord a) (ds :: [a]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ a
                   : x ds1
                   -> case ds1 of wild1 {
                        [] -> GHC.Types.: @ a x (GHC.Types.[] @ a)
                        : ipv ipv1
                        -> case GHC.List.$wlenAcc @ a wild 0# of ww2 { DEFAULT ->
                           Sorting.$wchamadaHeap
                             @ a
                             $dOrd
                             (GHC.Prim.-# ww2 1#)
                             (Sorting.$wconstruirHeap
                                @ a
                                $dOrd
                                (GHC.Prim.uncheckedIShiftRA# ww2 1#)
                                wild) } } }) -}
9926069df372edaeaaa1c90c69e2461b
  inserir :: GHC.Classes.Ord a => a -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>m2,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: a) (w2 :: [a]) ->
                 case Sorting.$winserir @ a w w1 w2 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ a ww1 ww2 }) -}
eef5d1e838d10620c3731e245a4dbaca
  insertionSort :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U> -}
bbd5df9d1f9f63b23acf2ea22e29b982
  insertionSort_$sinsertionSort :: [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ae92d5598f7427712adfc6567ca086ec
  intercalar :: GHC.Classes.Ord a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U><S,1*U> -}
84a4f78bb0ed8d7980e3bb0f99a862d0
  maiorElemento :: [GHC.Types.Int] -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (0, True, True)
                GHC.List.maximum_$smaximum1 -}
20aa9ee90f729e4c99b96f4b44a72373
  maxHeapify ::
    GHC.Classes.Ord a => GHC.Types.Int -> GHC.Types.Int -> [a] -> [a]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,C(C1(U)),A,A,A)><S(S),1*U(U)><S(S),1*U(U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Types.Int)
                   (w3 :: [a]) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { GHC.Types.I# ww3 ->
                 Sorting.$wmaxHeapify @ a w ww1 ww3 w3 } }) -}
d23ac9a57c8e548378411b6fa348d458
  mergeSort :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U> -}
50557a1a899935cdf704deccc1dbe729
  numDigitos :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(U)>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 case Sorting.$wnumDigitos ww1 ww3 of ww4 { DEFAULT ->
                 GHC.Types.I# ww4 } } }) -}
1549984d954d5b7e955e7e7c2ec8837c
  obterDigito :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*U(1*U)>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case Sorting.$wobterDigito ww1 w1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
8c3b9072ea28840fa5591b872fb41a86
  obterDigitos ::
    [GHC.Types.Int]
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U(U)><L,U(U)> -}
e360ca7bdafe91c9a3800078818683ce
  ordenado :: GHC.Classes.Ord a => [a] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U> -}
cce45c2c312223ed03411b9e455b1310
  ordenarBuckets :: [[GHC.Types.Int]] -> [[GHC.Types.Int]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
12ab7d67cad29b5ea36f44f51bb01c43
  ordenarDigitos ::
    [(GHC.Types.Int, GHC.Types.Int)] -> [GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ts :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 Sorting.chamadaRadix_go
                   (Sorting.chamadaRadix_$sselectionSort ts)) -}
9591c2681daa0a648c596ea3db969f88
  quickSort :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,C(C1(U)),A,A)><S,1*U> -}
40a9db0f224b4137dca0a7035e772e87
  radix ::
    [GHC.Types.Int]
    -> GHC.Types.Int -> GHC.Types.Int -> [GHC.Types.Int]
  {- Arity: 3, Strictness: <S,U><S(S),1*U(U)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: [GHC.Types.Int])
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { GHC.Types.I# ww3 ->
                 Sorting.$wradix w ww1 ww3 } }) -}
6d198e5b934873014493838f4bf0094a
  radixSort :: [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [GHC.Types.Int]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Int
                   : x ds1
                   -> case ds1 of wild1 {
                        [] -> GHC.Types.: @ GHC.Types.Int x (GHC.Types.[] @ GHC.Types.Int)
                        : ipv ipv1
                        -> case x of ww { GHC.Types.I# ww1 ->
                           case GHC.List.$wgo wild1 ww1 of ww2 { DEFAULT ->
                           case Sorting.$wnumDigitos ww2 0# of ww4 { DEFAULT ->
                           Sorting.$wradix wild 1# ww4 } } } } }) -}
88b82ffc4286a0faddb2d5eeb1145147
  recuperarNumeros ::
    [GHC.Types.Int] -> [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (xs :: [GHC.Types.Int]) (is :: [GHC.Types.Int]) ->
                 letrec {
                   go :: [GHC.Types.Int] -> [GHC.Types.Int]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Types.Int]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Int
                       : y ys
                       -> GHC.Types.:
                            @ GHC.Types.Int
                            (GHC.List.!! @ GHC.Types.Int xs y)
                            (go ys) }
                 } in
                 go is) -}
4a82c35c43f41869168293c6a4c4752e
  remover :: GHC.Classes.Ord a => a -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),A,A,A,A,A,A,A)><L,U><S,1*U> -}
a1e7d1f766a1f3b318954b490fa10cdc
  remover_$sremover ::
    (GHC.Types.Int, GHC.Types.Int)
    -> [(GHC.Types.Int, GHC.Types.Int)]
    -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U(U),U(U))><S,1*U> -}
bcc24d14bc11c03754f9e55676b432b6
  selectionSort :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2,
     Strictness: <L,U(U(C(C1(U)),A),A,A,A,A,A,A,C(C1(U)))><S,1*U> -}
321032b5949383f1bda5d53de8494c71
  tamanhoAuxiliar :: [GHC.Types.Int] -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [GHC.Types.Int]) ->
                 case Sorting.$wtamanhoAuxiliar w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
821ffe02438c5575a66013ec579a199a
  trocar ::
    GHC.Classes.Ord a => GHC.Types.Int -> GHC.Types.Int -> [a] -> [a]
  {- Arity: 4, Strictness: <L,A><S(S),1*U(U)><S(S),1*U(U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Types.Int)
                   (w3 :: [a]) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { GHC.Types.I# ww3 ->
                 Sorting.$wtrocar @ a ww1 ww3 w3 } }) -}
"SPEC insertionSort @ Int" forall ($dOrd :: GHC.Classes.Ord
                                              GHC.Types.Int)
  Sorting.insertionSort @ GHC.Types.Int $dOrd
  = Sorting.insertionSort_$sinsertionSort
"SPEC remover @ (Int, Int)" forall ($dOrd :: GHC.Classes.Ord
                                               (GHC.Types.Int, GHC.Types.Int))
  Sorting.remover @ (GHC.Types.Int, GHC.Types.Int) $dOrd
  = Sorting.remover_$sremover
"SPEC selectionSort @ (Int, Int)" forall ($dOrd :: GHC.Classes.Ord
                                                     (GHC.Types.Int, GHC.Types.Int))
  Sorting.selectionSort @ (GHC.Types.Int, GHC.Types.Int) $dOrd
  = Sorting.chamadaRadix_$sselectionSort
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

